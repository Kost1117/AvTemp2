//============================================================================
// Name        : AvTemp2.cpp
// Author      : Oleg Kostyuchenko
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================

#include <iostream>
#include <vector>

using namespace std;

int main()
{
	int Q;
	cin >> Q;
	int sum = 0;
	vector<int> temp(Q);

	for (auto& i : temp)
	{
		cin >> i;
		sum += i;
	}
	int avn = sum / temp.size();				// »спользуем метод size() дл€ определени€ среднего значени€.
												// ћетод size() у контейнеров C++ возвращает беззнаковый тип size_t
												// ѕеред алгебраическими операци€ми и сравнени€ми типы привод€тс€ следующим образом

												// 1. ¬се типы меньше int к int
												// 2. »з 2-х типов выбираетс€ больший по размеру
												// 3. ≈сли размер одинаковый, то выбираетс€ беззнаковый тип

												// “аким образом sum из знакового int была приведена к беззнаковому типу size_t
												// Ёто называетс€ не€вное приведение типов
												// ѕроблема в том, что sum может в данном случае принимать отрицательные значени€
												// в результате чего происходит переполнение sum, и программа не ведет себ€ ожидаемым образом
	cout << "Average value = " << avn << endl;
	/*
	for (int& i : temp)
	{
		cin >> i;
		sum += i;
	}
	int avn = sum / Q;							// ј вот в этой строке уже не будет проблемы с переполнением
												// так как Q не €вл€етс€ переменной беззнакового типа. Q это int,
												// и деление int на int проблем с не€вным преобразованием вызывать не может.
	*/

	vector<int> result;

	for (int i = 0; i < Q; ++i)
	{
		if (temp[i] > avn)
		{
			result.push_back(i);
		}
	}
	cout << result.size() << endl;

	for (auto i : result)
	{
		cout << i << " ";
	}
	return 0;
}
